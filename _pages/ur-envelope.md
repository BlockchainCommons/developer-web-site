---
cover: false
header:
  overlay_color: "#000"
  overlay_filter: "0.25"
  overlay_image: /assets/images/dev-data-background.jpg
  og_image: /assets/images/bc-card.jpg
title: A Guide to Using URs for Envelopes
hide_description: true
classes:
  - wide
permalink: /ur/envelope/
sidebar:
  nav:
    - ur
---

Bare Uniform Resources (URs) allow for the encoding of a variety of
information, including a variety of crypto-data. It was originally Blockchain Commons' suggested methodology to encode CBOR data such as seeds and private keys in a self-describing way.

However, following the release of URs, Blockchain Commons developed the [Gordian Envelope](/envelope/) format. This "Smart Document" system describes how to use CBOR in a more comprehensive way to encode data so that it's not only self-describing, but also privacy-focused. It also allows for much more data to be stored together due to its ability to model more complex structures. Envelope is now Blockchain Commons' preferred methodology for data storage.

UR nonetheless remains relevant: it's a way to encode binary CBOR in a hardened, easily transmissible way using plain text and checksums. Envelopes can therefore be encoded for transmission using URs (and therefore [Animated QRs](/animated-qrs/), offering all of the original advantages of URs to the more robust and extensive Envelope data format.

## Why Use URs for Envelopes?

Gordian Envelopes can be kept in memory or stored as a binary stream. However, there are many situations when you might want to store or transmit them when the UR format will offer all of its normal benefits:

1. **Improves Self-Description.** The content within a Gordian Envelope is all self-described by CBOR tags. But how do you know that big blob of data is a Gordian Envelope at all? That's where `ur:envelope` comes in. 
1. **Offers Error Checking.** The checksum digits at the end of a UR can identify if an Envelope has been corrupted.
1. **Allows Printing.** URs can be printed out and stored. Though Envelope URs can be very long and therefore a huge pain to reenter, doing so might allow the recovery of otherwise lost data.
1. **Supports Animated QRs.** URs are built to be efficiently encoded as QRs. This allows Envelopes to be stored as QRs or even Animated QRs for larger data. This allows the easy transmission of Envelopes across [airgaps](/airgaps/). This also allows for much easier recovery fromt printed content, even for larger Envelopes, as Animated QRs can be printed out using multiple frames.

None of these advantages are unique to Envelopes: they're all general advantages of the UR form that can be extended to Envelopes stored as URs.

## Envelopes: `[envelope]`

Envelopes allow for the encoding of semantic triples, as shown in the following example generated by the [bc-envelope-cli-rust tool](https://github.com/BlockchainCommons/bc-envelope-cli-rust/tree/master):
```
$ ENVELOPE=`envelope subject type string alice | envelope assertion add pred-obj string knows string bob`
```
The `envelope-cli` actually encodes its data as a UR for default, because it's such a useful format for data storage of this type
```
$ echo $ENVELOPE
ur:envelope/lftpsoihhsjziniaihoytpsoihjejtjlktjktpsoiaidjlidzmvllokt
```
The `envelope-cli` tool also allows the output of this data in Envelope format, which clearly shows what's being stored:
```
$ envelope format $ENVELOPE
"alice" [
    "knows": "bob"
]
```
However, the data is actually written as CBOR using the [Envelope IETF spec](https://datatracker.ietf.org/doc/draft-mcnally-envelope/) prior to its output as a UR. As of this writing, the following CDDL description details how an Envelope is encoded:

```
   envelope = #6.200(envelope-content)
   envelope-content =
       leaf /
       elided /
       node /
       assertion /
       wrapped

   leaf = #6.201(any)

   elided = sha256-digest
   sha256-digest = bytes .size 32

   node = [subject, + assertion-element]
   subject = envelope-content
   assertion-element = assertion / elided-assertion
   elided-assertion = elided           ; MUST represent an assertion.

   assertion = { predicate => object }
   predicate = envelope-content
   object = envelope-content

   wrapped = envelope
```
You can examine what the original CBOR for a `ur:envelope` encoding looks like using a few other tools. Remember that each UR is divided into a self-description (`ur:envelope/`) and a set of minimal [Bytewords](/bytewords/) that encode the CBOR and then provide a checksum (`lftpsoihhsjziniaihoytpsoihjejtjlktjktpsoiaidjlidzmvllokt`). To convert the UR back to CBOR, you must first convert the minimal bytewords back to hex.

Blockchain Commons [`bytewords-cli`](https://github.com/BlockchainCommons/bytewords-cli) provides the easiest way to do so:
```
$ bytewords -i minimal -o hex lftpsoihhsjziniaihoytpsoihjejtjlktjktpsoiaidjlidzmvllokt
82d8c965616c696365a1d8c9656b6e6f7773d8c963626f62
```
[cbor2diag](https://github.com/cabo/cbor-diag/tree/master) provides one way to do so:
```
$ cbor2diag -x 82d8c965616c696365a1d8c9656b6e6f7773d8c963626f62
[201("alice"), {201("knows"): 201("bob")}]
```
The [cbor.me website](https://cbor.me/) breaks down the CBOR even further:
```
82                     # array(2)
   D8 C9               # tag(201)
      65               # text(5)
         616C696365    # "alice"
   A1                  # map(1)
      D8 C9            # tag(201)
         65            # text(5)
            6B6E6F7773 # "knows"
      D8 C9            # tag(201)
         63            # text(3)
            626F62     # "bob"
```
As shown, this Envelope is an array of a subject ("alice") and an assertion, with the latter being a map containing "knows" and "bob". Each individual element of the Envelope is tagged `201` to mark it as an Envelope leaf, all in accordance with the [IETF spec](https://datatracker.ietf.org/doc/draft-mcnally-envelope/).

## Integrating Envelope URs Into Your Code

You can incorporate URs into your own code using the UR library of your choice:

{% include lib-ur.md %}

## Conclusion

PSBTs are perhaps the easiest data type to convert into URs. They also
offer one of the strongest use cases for URs.

1. The animated QRs that are easy to create using UR sequences are
very important for PSBTs because of their potential for large sizes,
particularly with multisig PSBTs.
2. The fact that PSBTs are very likely to be passed from device to
device makes their interoperability that much more important, and URs
(especially when integrated with QRs) offer a way to do so that's
accessible and easy to use for an average user, while its
self-describing nature also ensures that devices know what to do with
the data!

However, if you have any use case for incorporating additional data into your PSBT, such as descriptions or instructions, you should use [Gordian Envelope](/envelope/) instead. Since Gordian Envelopes encode as URs, they still have also these advantages, but also the additional benefits of being able to package the PSBT with more content and being able to use Envelope Extensions such as [GSTP](/envelope/gstp/), which allows for secure transmission of your PSBT by means other than QRs.
